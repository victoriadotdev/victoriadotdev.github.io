<!doctype html><html lang=en-us><head><head><meta charset=utf-8><meta name=mobile-web-app-capable content="yes"><meta name=viewport content="width=device-width,initial-scale=1"><title>victoria.dev</title><meta name=monetization content="$ilp.uphold.com/pBRfRwg2EJAe"><link rel="shortcut icon" href=https://victoria.dev/favicon.ico><link rel=icon type=image/png href=https://victoria.dev/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://victoria.dev/favicon-16x16.png sizes=16x16><link rel=authorization_endpoint href=https://indieauth.com/auth><link rel=token_endpoint href=https://tokens.indieauth.com/token><link rel=me href=https://github.com/victoriadrake><link rel=me href=https://twitter.com/victoriadotdev><link rel=me href=https://mastodon.technology/@victoria><link rel=stylesheet href=https://victoria.dev/css/style.css crossorigin=anonymous media=screen><link rel=webmention href=https://webmention.io/victoria.dev/webmention><link rel=pingback href=https://webmention.io/victoria.dev/xmlrpc><meta property="og:url" content="https://victoria.dev/"><meta property="og:title" content="victoria.dev"><meta property="og:site_name" content="victoria.dev"><meta property="og:type" content="website"><meta name=twitter:title content="victoria.dev"></head></head><body><header role=banner><nav aria-label="Victoria.dev main menu" id=menu><ul role=menubar><li role=none class=menu-item><a role=menuitem href=/><img src=/icon/bookmark.svg alt="home page icon" height=18px class=filter-icon>&nbsp;hello</a></li><li role=none class=menu-item><a role=menuitem href=/blog/><img src=/icon/quote.svg alt="blog icon" height=18px class=filter-icon>&nbsp;blog</a></li><li role=none class=menu-item><a role=menuitem href=/about/><img src=/icon/profile.svg alt="about page icon" height=18px class=filter-icon>&nbsp;about</a></li><li role=none class=menu-item><a role=menuitem href=/bookshelf/><img src=/icon/book.svg alt="bookshelf icon" height=18px class=filter-icon>&nbsp;bookshelf</a></li></ul></nav></header><main aria-role=main><div class=container><div id=cover-image><img class=u-photo src=https://victoria.dev/blog/multithreaded-python-slithering-through-an-i/o-bottleneck/cover.png alt="cover image"></div><article class=h-entry><h1 class=p-name>Multithreaded Python: slithering through an I/O bottleneck</h1><p class=subtitle>How taking advantage of parallelism in Python can make your software orders of magnitude faster.</p><span><a class="p-category tag button" href=/tags/python/>python
</a>&nbsp;
<a class="p-category tag button" href=/tags/computing/>computing
</a>&nbsp;
<a class="p-category tag button" href=/tags/ci/cd/>ci/cd
</a>&nbsp;
<a class="p-category tag button" href=/tags/data/>data
</a>&nbsp;
<a class="p-category tag button" href=/tags/open-source/>open-source
</a>&nbsp;</span>
<span rel=author class="p-author h-card"><img class="u-photo hidden" src=/img/victoria_headshot.jpg>
<span class="p-name hidden" rel=me>Victoria Drake</span></span><p class=metadata id=date><time class="hidden dt-published">2020-02-28 09:31:02 -0500 -0500</time>
<a class=u-url href=https://victoria.dev/blog/multithreaded-python-slithering-through-an-i/o-bottleneck/>February 28, 2020</a>
<span class=dt-updated>&nbsp;<em>Updated: May 25, 2021</em></span>
<span>&nbsp;5 min read</span></p></p><div class=page-separator><hr></div><div class="markdown e-content"><p>I recently developed a project that I called <a href=https://github.com/victoriadrake/hydra-link-checker>Hydra</a>: a multithreaded link checker written in Python. Unlike many Python site crawlers I found while researching, Hydra uses only standard libraries, with no external dependencies like BeautifulSoup. It&rsquo;s intended to be run as part of a CI/CD process, so part of its success depended on being fast.</p><p>Multiple threads in Python is a bit of a bitey subject (not sorry) in that the Python interpreter doesn&rsquo;t actually let multiple threads execute at the same time. Python&rsquo;s <a href=https://wiki.python.org/moin/GlobalInterpreterLock>Global Interpreter Lock</a>, or GIL, prevents multiple threads from executing Python bytecodes at once. Each thread that wants to execute must first wait for the GIL to be released by the currently executing thread. The GIL is pretty much the microphone in a low-budget conference panel, except where no one gets to shout.</p><p>This has the advantage of preventing <a href=https://en.wikipedia.org/wiki/Race_condition>race conditions</a>. It does, however, lack the performance advantages afforded by running multiple tasks in parallel. (If you&rsquo;d like a refresher on concurrency, parallelism, and multithreading, see <a href=/blog/concurrency-parallelism-and-the-many-threads-of-santa-claus/>Concurrency, parallelism, and the many threads of Santa Claus</a>.) While I prefer Go for its convenient first-class primitives that support concurrency (see <a href=https://tour.golang.org/concurrency/1>Goroutines</a>), this project&rsquo;s recipients were more comfortable with Python. I took it as an opportunity to test and explore!</p><p>Simultaneously performing multiple tasks in Python isn&rsquo;t impossible; it just takes a little extra work. For Hydra, the main advantage is in overcoming the input/output (I/O) bottleneck.</p><p>In order to get web pages to check, Hydra needs to go out to the Internet and fetch them. When compared to tasks that are performed by the CPU alone, going out over the network is comparatively slower. How slow?</p><p>Here are approximate timings for tasks performed on a typical PC:</p><table><thead><tr><th></th><th>Task</th><th>Time</th></tr></thead><tbody><tr><td>CPU</td><td>execute typical instruction</td><td>1/1,000,000,000 sec = 1 nanosec</td></tr><tr><td>CPU</td><td>fetch from L1 cache memory</td><td>0.5 nanosec</td></tr><tr><td>CPU</td><td>branch misprediction</td><td>5 nanosec</td></tr><tr><td>CPU</td><td>fetch from L2 cache memory</td><td>7 nanosec</td></tr><tr><td>RAM</td><td>Mutex lock/unlock</td><td>25 nanosec</td></tr><tr><td>RAM</td><td>fetch from main memory</td><td>100 nanosec</td></tr><tr><td>Network</td><td>send 2K bytes over 1Gbps network</td><td>20,000 nanosec</td></tr><tr><td>RAM</td><td>read 1MB sequentially from memory</td><td>250,000 nanosec</td></tr><tr><td>Disk</td><td>fetch from new disk location (seek)</td><td>8,000,000 nanosec (8ms)</td></tr><tr><td>Disk</td><td>read 1MB sequentially from disk</td><td>20,000,000 nanosec (20ms)</td></tr><tr><td>Network</td><td>send packet US to Europe and back</td><td>150,000,000 nanosec (150ms)</td></tr></tbody></table><p>Peter Norvig first published these numbers some years ago in <a href=http://norvig.com/21-days.html#answers>Teach Yourself Programming in Ten Years</a>. Since computers and their components change year over year, the exact numbers shown above aren&rsquo;t the point. What these numbers help to illustrate is the difference, in orders of magnitude, between operations.</p><p>Compare the difference between fetching from main memory and sending a simple packet over the Internet. While both these operations occur in less than the blink of an eye (literally) from a human perspective, you can see that sending a simple packet over the Internet is over a million times slower than fetching from RAM. It&rsquo;s a difference that, in a single-thread program, can quickly accumulate to form troublesome bottlenecks.</p><p>In Hydra, the task of parsing response data and assembling results into a report is relatively fast, since it all happens on the CPU. The slowest portion of the program&rsquo;s execution, by over six orders of magnitude, is network latency. Not only does Hydra need to fetch packets, but whole web pages! One way of improving Hydra&rsquo;s performance is to find a way for the page fetching tasks to execute without blocking the main thread.</p><p>Python has a couple options for doing tasks in parallel: multiple processes, or multiple threads. These methods allow you to circumvent the GIL and speed up execution in a couple different ways.</p><h2 id=multiple-processes>Multiple processes</h2><p>To execute parallel tasks using multiple processes, you can use Python&rsquo;s <a href=https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor><code>ProcessPoolExecutor</code></a>. A concrete subclass of <a href=https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor><code>Executor</code></a> from the <a href=https://docs.python.org/3/library/concurrent.futures.html><code>concurrent.futures</code> module</a>, <code>ProcessPoolExecutor</code> uses a pool of processes spawned with the <a href=https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing><code>multiprocessing</code> module</a> to avoid the GIL.</p><p>This option uses worker subprocesses that maximally default to the number of processors on the machine. The <code>multiprocessing</code> module allows you to maximally parallelize function execution across processes, which can really speed up compute-bound (or <a href=https://en.wikipedia.org/wiki/CPU-bound>CPU-bound</a>) tasks.</p><p>Since the main bottleneck for Hydra is I/O and not the processing to be done by the CPU, I&rsquo;m better served by using multiple threads.</p><h2 id=multiple-threads>Multiple threads</h2><p>Fittingly named, Python&rsquo;s <a href=https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ThreadPoolExecutor><code>ThreadPoolExecutor</code></a> uses a pool of threads to execute asynchronous tasks. Also a subclass of <a href=https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor><code>Executor</code></a>, it uses a defined number of maximum worker threads (at least five by default, according to the formula <code>min(32, os.cpu_count() + 4)</code>) and reuses idle threads before starting new ones, making it pretty efficient.</p><p>Here is a snippet of Hydra with comments showing how Hydra uses <code>ThreadPoolExecutor</code> to achieve parallel multithreaded bliss:</p><div class=highlight><pre class=chroma><code class=language-py data-lang=py><span class=c1># Create the Checker class</span>
<span class=k>class</span> <span class=nc>Checker</span><span class=p>:</span>
    <span class=c1># Queue of links to be checked</span>
    <span class=n>TO_PROCESS</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>()</span>
    <span class=c1># Maximum workers to run</span>
    <span class=n>THREADS</span> <span class=o>=</span> <span class=mi>100</span>
    <span class=c1># Maximum seconds to wait for HTTP response</span>
    <span class=n>TIMEOUT</span> <span class=o>=</span> <span class=mi>60</span>

    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>url</span><span class=p>):</span>
        <span class=o>...</span>
        <span class=c1># Create the thread pool</span>
        <span class=bp>self</span><span class=o>.</span><span class=n>pool</span> <span class=o>=</span> <span class=n>futures</span><span class=o>.</span><span class=n>ThreadPoolExecutor</span><span class=p>(</span><span class=n>max_workers</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>THREADS</span><span class=p>)</span>


<span class=k>def</span> <span class=nf>run</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
    <span class=c1># Run until the TO_PROCESS queue is empty</span>
    <span class=k>while</span> <span class=bp>True</span><span class=p>:</span>
        <span class=k>try</span><span class=p>:</span>
            <span class=n>target_url</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>TO_PROCESS</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>block</span><span class=o>=</span><span class=bp>True</span><span class=p>,</span> <span class=n>timeout</span><span class=o>=</span><span class=mi>2</span><span class=p>)</span>
            <span class=c1># If we haven&#39;t already checked this link</span>
            <span class=k>if</span> <span class=n>target_url</span><span class=p>[</span><span class=s2>&#34;url&#34;</span><span class=p>]</span> <span class=ow>not</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>visited</span><span class=p>:</span>
                <span class=c1># Mark it as visited</span>
                <span class=bp>self</span><span class=o>.</span><span class=n>visited</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>target_url</span><span class=p>[</span><span class=s2>&#34;url&#34;</span><span class=p>])</span>
                <span class=c1># Submit the link to the pool</span>
                <span class=n>job</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>pool</span><span class=o>.</span><span class=n>submit</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>load_url</span><span class=p>,</span> <span class=n>target_url</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>TIMEOUT</span><span class=p>)</span>
                <span class=n>job</span><span class=o>.</span><span class=n>add_done_callback</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>handle_future</span><span class=p>)</span>
        <span class=k>except</span> <span class=n>Empty</span><span class=p>:</span>
            <span class=k>return</span>
        <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
            <span class=k>print</span><span class=p>(</span><span class=n>e</span><span class=p>)</span>
</code></pre></div><p>You can view the full code in <a href=https://github.com/victoriadrake/hydra-link-checker>Hydra&rsquo;s GitHub repository</a>.</p><h2 id=single-thread-to-multithread>Single thread to multithread</h2><p>If you&rsquo;d like to see the full effect, I compared the run times for checking my website between a prototype single-thread program, and the <del>multiheaded</del>multithreaded Hydra.</p><div class=highlight><pre class=chroma><code class=language-text data-lang=text>time python3 slow-link-check.py https://victoria.dev

real    17m34.084s
user    11m40.761s
sys     0m5.436s


time python3 hydra.py https://victoria.dev

real    0m15.729s
user    0m11.071s
sys     0m2.526s
</code></pre></div><p>The single-thread program, which blocks on I/O, ran in about seventeen minutes. When I first ran the multithreaded version, it finished in 1m13.358s - after some profiling and tuning, it took a little under sixteen seconds. Again, the exact times don&rsquo;t mean all that much; they&rsquo;ll vary depending on factors such as the size of the site being crawled, your network speed, and your program&rsquo;s balance between the overhead of thread management and the benefits of parallelism.</p><p>The more important thing, and the result I&rsquo;ll take any day, is a program that runs some orders of magnitude faster.</p></div><a class=hidden href=https://brid.gy/publish/twitter></a><a class=hidden href=https://brid.gy/publish/mastodon></a><data class=p-bridgy-omit-link value=false></data></article><div id=up-container><a href=# id=up>v</a></div><hr><div id=webmentions></div><div class=related><code class=language-sql data-lang=sql>SELECT TOP 3 * FROM Related;</code><ul role=menubar id=article-list><li role=none class=h-entry><a rel=author class="p-author h-card hidden" href=https://victoria.dev/>Victoria Drake</a>
<a role=menuitem class="article-link u-url p-name" href=https://victoria.dev/blog/breaking-bottlenecks/>Breaking bottlenecks 🍾</a><p class="p-summary e-content">A talk on the benefits of non-blocking functions for programs, developers, and organizations.</p><p class=metadata><a class="p-category tag button" href=https://victoria.dev/tags/computing/>computing</a>
&nbsp;12 min read
<time class="hidden dt-published">2020-02-25 12:50:29 -0500 -0500</time></p></li><li role=none class=h-entry><a rel=author class="p-author h-card hidden" href=https://victoria.dev/>Victoria Drake</a>
<a role=menuitem class="article-link u-url p-name" href=https://victoria.dev/blog/what-is-tcp/ip-layers-and-protocols-explained/>What is TCP/IP? Layers and protocols explained</a><p class="p-summary e-content">Alternatively titled, "Why the Internet Protocol Suite is an imaginary rainbow layer cake"</p><p class=metadata><a class="p-category tag button" href=https://victoria.dev/tags/computing/>computing</a>
&nbsp;5 min read
<time class="hidden dt-published">2020-11-29 04:01:22 -0400 -0400</time></p></li><li role=none class=h-entry><a rel=author class="p-author h-card hidden" href=https://victoria.dev/>Victoria Drake</a>
<a role=menuitem class="article-link u-url p-name" href=https://victoria.dev/blog/manipulating-data-with-django-migrations/>Manipulating data with Django migrations</a><p class="p-summary e-content">How to update Django models and manipulate existing data using migrations.</p><p class=metadata><a class="p-category tag button" href=https://victoria.dev/tags/coding/>coding</a>
&nbsp;5 min read
<time class="hidden dt-published">2020-09-14 02:12:57 -0400 -0400</time></p></li></ul><div class=page-separator><p class=back-link><a href=/blog>&lt;&lt; Back to blog</a></p></div></div></div><footer class=container><div class="h-card row bio" rel=author><div class=markdown id=card><figure class=profile><img class=u-photo alt="Victoria Drake" src=/img/victoria_headshot.jpg></figure><h1 class=p-name>Victoria Drake</h1></address><p class=p-note><p>Victoria Drake is a Director of Engineering in Washington, DC. She is a core maintainer and co-author for the Open Web Application Security Project (OWASP) Web Security Testing Guide. She earned the annual Top Contributor award three years in a row from the freeCodeCamp non-profit, and was recognized two years in a row as a Distinguished Author on the DEV.to developer platform. She writes and educates programmers and business leaders about cybersecurity, software development, and building happy and productive technical teams.</p><p><a href=/about>about</a> - <a href=/about/#write-me>contact</a> - <a href=https://github.com/victoriadrake>github</a> - <a href=https://twitter.com/victoriadotdev>twitter</a> - <a href=https://www.linkedin.com/in/victoriadotdev/>linkedin</a></p></p></div></div></footer></main><nav aria-label="Victoria.dev menu for mobile" id=menu-mobile><ul role=menubar><li role=none class=menu-item><a role=menuitem href=/><img src=/icon/bookmark.svg alt="home page icon" height=18px class=filter-icon></a></li><li role=none class=menu-item><a role=menuitem href=/blog/><img src=/icon/quote.svg alt="blog icon" height=18px class=filter-icon></a></li><li role=none class=menu-item><a role=menuitem href=/about/><img src=/icon/profile.svg alt="about page icon" height=18px class=filter-icon></a></li><li role=none class=menu-item><a role=menuitem href=/bookshelf/><img src=/icon/book.svg alt="bookshelf icon" height=18px class=filter-icon></a></li></ul></nav><script src=/js/webmention.min.js data-wordcount=100 async></script></body></html>